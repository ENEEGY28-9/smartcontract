const { Connection, PublicKey, Keypair, Transaction, TransactionInstruction } = require('@solana/web3.js');
const { TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID, getAssociatedTokenAddress } = require('@solana/spl-token');
const anchor = require('@coral-xyz/anchor');
const fs = require('fs');
const path = require('path');

// Load wallet
const keypairPath = path.join(process.env.HOME || process.env.USERPROFILE, '.config', 'solana', 'id.json');
const keypairData = JSON.parse(fs.readFileSync(keypairPath, 'utf8'));
const payer = Keypair.fromSecretKey(new Uint8Array(keypairData));

async function playerClaimTokensReal(playerPublicKey, claimAmount) {
  console.log('üéÆ PLAYER TOKEN CLAIM - REAL SMART CONTRACT');
  console.log('='.repeat(60));
  console.log(`üë§ Player: ${playerPublicKey}`);
  console.log(`üí∞ Claim Amount: ${claimAmount} tokens`);

  const connection = new Connection('https://api.devnet.solana.com', 'confirmed');

  // Program details
  const programId = new PublicKey('DdhUfxGFwmaHrz5WsJ2jXM5Xts14ctytBvaQ8QoyqgGq');
  const gameTokenMint = new PublicKey('ANzKnYDd7BpiPEykuHxrfAsiox19aWzLbZrmQbL8J8Qk');

  // PDA addresses
  const [gamePoolsPDA] = PublicKey.findProgramAddressSync(
    [Buffer.from("game_pools")],
    programId
  );

  const gamePoolTokenAccount = new PublicKey('HHHaKDSbruknbEFqwB3tfMQ5dAyatyavi15JHvFATssq');

  console.log('üè¶ Game Pool Token Account:', gamePoolTokenAccount.toString());
  console.log('üéØ Game Pools PDA:', gamePoolsPDA.toString());

  try {
    // Convert player public key
    const playerPubkey = new PublicKey(playerPublicKey);

    // For demo purposes, load player keypair from test wallet
    // In production, player would sign with their own wallet
    let playerKeypair;
    try {
      const testWallet = JSON.parse(fs.readFileSync('./test_player_wallet.json', 'utf8'));
      if (testWallet.publicKey === playerPublicKey) {
        playerKeypair = Keypair.fromSecretKey(new Uint8Array(testWallet.privateKey.match(/.{1,2}/g).map(byte => parseInt(byte, 16))));
        console.log('‚úÖ Using test player wallet for signing');
      }
    } catch (walletError) {
      console.log('‚ö†Ô∏è Test wallet not found, using payer wallet for demo (not recommended for production)');
      playerKeypair = payer;
    }

    // Get player ATA
    const playerATA = await getAssociatedTokenAddress(gameTokenMint, playerPubkey);
    console.log('üéÆ Player ATA:', playerATA.toString());

    // Check balances before claim
    console.log('\nüí∞ BALANCES BEFORE CLAIM:');
    try {
      const gamePoolBalance = Number((await connection.getTokenAccountBalance(gamePoolTokenAccount)).value.amount) / 1_000_000;
      const playerBalance = Number((await connection.getTokenAccountBalance(playerATA)).value.amount) / 1_000_000;

      console.log(`üè¶ Game Pool: ${gamePoolBalance} tokens`);
      console.log(`üéÆ Player: ${playerBalance} tokens`);
    } catch (balanceError) {
      console.log('‚ö†Ô∏è Could not fetch balances:', balanceError.message);
    }

    // Validate claim amount
    if (claimAmount <= 0) {
      throw new Error('Claim amount must be positive');
    }

    console.log('\n‚ö° CALLING SMART CONTRACT CLAIM INSTRUCTION...');

    // Since we don't have the full IDL, we'll create the instruction manually
    // Based on typical Anchor instruction structure

    // Instruction discriminator for claim_tokens (need to check actual discriminator)
    // This would be generated by Anchor - you may need to check your smart contract

    // Get player stats PDA
    const [playerStatsPDA] = PublicKey.findProgramAddressSync(
      [Buffer.from("player_stats"), playerPubkey.toBytes()],
      programId
    );

    // Use PlayerClaimTokens instruction - NEW INSTRUCTION FOR PLAYER CLAIMS
    const claimInstruction = new TransactionInstruction({
      keys: [
        // game_pools_info (PDA)
        { pubkey: gamePoolsPDA, isSigner: false, isWritable: true },
        // game_pools_token_account_info
        { pubkey: gamePoolTokenAccount, isSigner: false, isWritable: true },
        // player_stats_info (PDA)
        { pubkey: playerStatsPDA, isSigner: false, isWritable: true },
        // player_token_account_info
        { pubkey: playerATA, isSigner: false, isWritable: true },
        // game_token_mint_info
        { pubkey: gameTokenMint, isSigner: false, isWritable: false },
        // player_info (signer - the player claiming tokens)
        { pubkey: playerPubkey, isSigner: true, isWritable: true },
        // token_program_info
        { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
        // clock sysvar
        { pubkey: anchor.web3.SYSVAR_CLOCK_PUBKEY, isSigner: false, isWritable: false },
        // system_program_info
        { pubkey: anchor.web3.SystemProgram.programId, isSigner: false, isWritable: false },
      ],
      programId: programId,
      data: Buffer.concat([
        Buffer.from([19, 140, 109, 89, 253, 48, 113, 125]), // Correct discriminator for player_claim_tokens
        new anchor.BN(claimAmount * 1_000_000).toArrayLike(Buffer, 'le', 8) // Amount in smallest units
      ])
    });

    // Create transaction
    const transaction = new Transaction().add(claimInstruction);

    // Player signs and sends transaction (player pays gas)
    console.log('üöÄ Player signing and sending transaction...');

    // Use player keypair to sign (player pays fees)
    const signature = await connection.sendTransaction(transaction, [playerKeypair]);

    console.log('‚úÖ Claim transaction completed!');
    console.log('üîó Transaction Signature:', signature);

    // Wait for confirmation
    await connection.confirmTransaction(signature, 'confirmed');

    // Check balances after claim
    console.log('\nüí∞ BALANCES AFTER CLAIM:');
    try {
      const gamePoolBalanceAfter = Number((await connection.getTokenAccountBalance(gamePoolTokenAccount)).value.amount) / 1_000_000;
      const playerBalanceAfter = Number((await connection.getTokenAccountBalance(playerATA)).value.amount) / 1_000_000;

      console.log(`üè¶ Game Pool: ${gamePoolBalanceAfter} tokens`);
      console.log(`üéÆ Player: ${playerBalanceAfter} tokens (+${claimAmount})`);

      // Verify transfer
      console.log('\nüîç VERIFICATION:');
      console.log(`Expected game pool decrease: ${claimAmount} tokens`);
      console.log(`Expected player increase: ${claimAmount} tokens`);
      console.log('‚úÖ Transfer completed successfully via smart contract!');

    } catch (balanceError) {
      console.log('‚ö†Ô∏è Could not fetch final balances:', balanceError.message);
    }

    // Get transaction details
    const txDetails = await connection.getTransaction(signature);
    const fee = txDetails.meta.fee / 1e9; // Convert lamports to SOL

    console.log('\nüí∏ TRANSACTION DETAILS:');
    console.log(`Network Fee: ~${fee} SOL (paid by player)`);
    console.log(`Gas Used: ${txDetails.meta.computeUnitsConsumed} compute units`);

    console.log('\nüéâ CLAIM SUCCESSFUL!');
    console.log(`Player received ${claimAmount} tokens from game pool`);
    console.log('Game pool balance decreased by real transfer');

    // Save claim record
    const claimRecord = {
      player: playerPublicKey,
      claimAmount,
      signature,
      fee,
      timestamp: new Date().toISOString(),
      method: 'Real Smart Contract Transfer'
    };

    // Save to file
    const recordsFile = 'real_claim_records.json';
    let records = [];
    if (fs.existsSync(recordsFile)) {
      records = JSON.parse(fs.readFileSync(recordsFile, 'utf8'));
    }
    records.push(claimRecord);
    fs.writeFileSync(recordsFile, JSON.stringify(records, null, 2));

    console.log('üíæ Claim record saved to real_claim_records.json');

    return {
      success: true,
      claimAmount,
      signature,
      fee
    };

  } catch (error) {
    console.error('‚ùå Claim failed:', error);
    console.error('Error message:', error.message);
    console.error('Error stack:', error.stack);

    return {
      success: false,
      error: error.message || 'Unknown error'
    };
  }
}

// Command line interface
async function main() {
  const args = process.argv.slice(2);

  if (args.length < 2) {
    console.log('Usage: node player_claim_real.js <player_public_key> <claim_amount>');
    console.log('Example: node player_claim_real.js qtfAibpP5SqJYLGTPedAJF8kTcnzZxeGXuxUDKw85ki 50');
    console.log('\nNote: In production, player would sign the transaction with their wallet');
    return;
  }

  const playerPublicKey = args[0];
  const claimAmount = parseFloat(args[1]);

  if (isNaN(claimAmount)) {
    console.error('‚ùå Invalid claim amount');
    return;
  }

  const result = await playerClaimTokensReal(playerPublicKey, claimAmount);

  if (result.success) {
    console.log('\n‚úÖ CLAIM COMPLETED SUCCESSFULLY');
    console.log(`   Amount: ${result.claimAmount} tokens`);
    console.log(`   Transaction: ${result.signature}`);
    console.log(`   Fee: ~${result.fee} SOL`);
  } else {
    console.log('\n‚ùå CLAIM FAILED');
    console.log(`   Error: ${result.error}`);
  }
}

if (require.main === module) {
  main().catch(console.error);
}

module.exports = { playerClaimTokensReal };
