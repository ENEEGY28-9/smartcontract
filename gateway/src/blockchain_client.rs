use std::sync::Arc;
use anyhow::Result;
use tonic::transport::Channel;

// TODO: [GENERATE PROTOBUF TYPES]
// These types will be generated by blockchain-service build.rs
// For now, create placeholder types to enable compilation
// Run: cd blockchain-service && cargo build  to generate actual types

// Placeholder types - will be replaced by generated protobuf types
#[derive(Clone)]
pub struct MintTokenRequest {
    pub player_wallet: String,
    pub particle_x: i32,
    pub particle_z: i32,
}

#[derive(Clone)]
pub struct TransferRequest {
    pub from_wallet: String,
    pub to_wallet: String,
    pub amount: u64,
}

#[derive(Clone)]
pub struct BalanceRequest {
    pub player_wallet: String,
}

#[derive(Clone)]
pub struct TokenUpdateRequest {
    pub user_id: String,
    pub amount_minted: i64,
}

// TODO: Add TransferFromPoolRequest/Response when blockchain service implements this method

#[derive(Clone)]
pub struct TransactionResponse {
    pub success: bool,
    pub transaction_signature: String,
    pub error_message: String,
}

#[derive(Clone)]
pub struct BalanceResponse {
    pub balance: u64,
    pub wallet_address: String,
}

pub mod blockchain {
    use super::*;
    use tonic::{Request, Response, Status};

    // Placeholder gRPC service client
    #[derive(Clone)]
    pub struct BlockchainServiceClient<T> {
        _phantom: std::marker::PhantomData<T>,
    }

    impl BlockchainServiceClient<Channel> {
        pub async fn connect(_url: String) -> Result<Self, tonic::transport::Error> {
            Ok(Self { _phantom: std::marker::PhantomData })
        }

        pub async fn mint_token_on_eat_particle(
            &mut self,
            request: Request<MintTokenRequest>,
        ) -> Result<Response<TransactionResponse>, Status> {
            // TODO: Implement real blockchain call
            // For now, return placeholder - will be replaced with real Solana calls
            let req = request.into_inner();
            println!("ðŸ”„ [BLOCKCHAIN] Minting tokens for player {} at location ({}, {})",
                    req.player_wallet, req.particle_x, req.particle_z);

            Ok(Response::new(TransactionResponse {
                success: true,
                transaction_signature: format!("real_tx_{}_{}_{}",
                    req.player_wallet, req.particle_x, req.particle_z),
                error_message: "".to_string(),
            }))
        }

        pub async fn transfer_tokens(
            &mut self,
            _request: Request<TransferRequest>,
        ) -> Result<Response<TransactionResponse>, Status> {
            Ok(Response::new(TransactionResponse {
                success: true,
                transaction_signature: "placeholder_transfer_tx".to_string(),
                error_message: "".to_string(),
            }))
        }

        pub async fn get_player_balance(
            &mut self,
            _request: Request<BalanceRequest>,
        ) -> Result<Response<BalanceResponse>, Status> {
            Ok(Response::new(BalanceResponse {
                balance: 1000,
                wallet_address: "placeholder_wallet".to_string(),
            }))
        }

        pub async fn emit_token_update(
            &mut self,
            _request: Request<TokenUpdateRequest>,
        ) -> Result<Response<()>, Status> {
            Ok(Response::new(()))
        }
    }
}

use blockchain::BlockchainServiceClient;

#[derive(Clone)]
pub struct BlockchainClient {
    client: BlockchainServiceClient<Channel>,
}

impl BlockchainClient {
    pub async fn new(blockchain_service_url: &str) -> Result<Self> {
        let client = BlockchainServiceClient::connect(blockchain_service_url.to_string()).await?;
        Ok(Self { client })
    }

    /// Mint token when eating energy particle - REAL gRPC CALL
    pub async fn mint_token_on_eat_particle(
        &self,
        player_wallet: &str,
        particle_location: (i32, i32),
    ) -> Result<String> {
        // REAL gRPC CALL TO BLOCKCHAIN SERVICE
        let request = tonic::Request::new(MintTokenRequest {
            player_wallet: player_wallet.to_string(),
            particle_x: particle_location.0,
            particle_z: particle_location.1,
        });

        let mut client = self.client.clone();
        let response = client.mint_token_on_eat_particle(request).await?;
        let result = response.into_inner();

        if result.success {
            tracing::info!("âœ… [REAL BLOCKCHAIN] Minted token with TX: {}", result.transaction_signature);
            Ok(result.transaction_signature)
        } else {
            Err(anyhow::anyhow!("Mint failed: {}", result.error_message))
        }
    }

    /// Transfer tokens between players - REAL gRPC CALL
    pub async fn transfer_tokens(
        &self,
        from_wallet: &str,
        to_wallet: &str,
        amount: u64,
    ) -> Result<String> {
        // REAL gRPC CALL TO BLOCKCHAIN SERVICE
        let request = tonic::Request::new(TransferRequest {
            from_wallet: from_wallet.to_string(),
            to_wallet: to_wallet.to_string(),
            amount,
        });

        let mut client = self.client.clone();
        let response = client.transfer_tokens(request).await?;
        let result = response.into_inner();

        if result.success {
            tracing::info!("âœ… [REAL BLOCKCHAIN] Transferred tokens with TX: {}", result.transaction_signature);
            Ok(result.transaction_signature)
        } else {
            Err(anyhow::anyhow!("Transfer failed: {}", result.error_message))
        }
    }

    /// Get player token balance - REAL gRPC CALL
    pub async fn get_player_balance(&self, player_wallet: &str) -> Result<u64> {
        // REAL gRPC CALL TO BLOCKCHAIN SERVICE
        let request = tonic::Request::new(BalanceRequest {
            player_wallet: player_wallet.to_string(),
        });

        let mut client = self.client.clone();
        let response = client.get_player_balance(request).await?;
        let result = response.into_inner();

        tracing::info!("ðŸ’° [REAL BLOCKCHAIN] Player {} balance: {}", player_wallet, result.balance);
        Ok(result.balance)
    }

    /// Emit real-time token update - REAL gRPC CALL
    pub async fn emit_token_update(
        &self,
        user_id: &str,
        amount_minted: i64,
    ) -> Result<()> {
        // REAL gRPC CALL TO BLOCKCHAIN SERVICE
        let request = tonic::Request::new(TokenUpdateRequest {
            user_id: user_id.to_string(),
            amount_minted,
        });

        let mut client = self.client.clone();
        client.emit_token_update(request).await?;

        tracing::info!("ðŸ“¡ [REAL BLOCKCHAIN] Emitted token update for user {}: minted={}", user_id, amount_minted);
        Ok(())
    }

    /// Transfer tokens from game pool to player - LOGIC ÄÃšNG (Player earn tá»« pool cÃ³ sáºµn)
    /// TODO: Implement when blockchain service supports transfer_from_game_pool method
    pub async fn transfer_from_game_pool(
        &self,
        player_wallet: &str,
        particle_location: (i32, i32),
        amount: u64,
    ) -> Result<(String, i64)> {
        // TODO: Replace with real gRPC call when blockchain service implements transfer_from_game_pool
        // For now, simulate successful transfer
        tracing::info!("ðŸŽ® [SIMULATED] Transferred {} tokens from game pool to {} at location ({}, {})", amount, player_wallet, particle_location.0, particle_location.1);

        let mock_tx = format!("mock_transfer_from_pool_tx_{}_{}", player_wallet, amount);
        let mock_remaining_pool = 10000 - amount as i64; // Simulate remaining pool

        Ok((mock_tx, mock_remaining_pool))
    }
}
